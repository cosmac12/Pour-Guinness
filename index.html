<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Guinness Pour - Touch Edition</title>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: sans-serif;
    color: white;
  }
  canvas {
    background: #222;
    border: 2px solid #666;
    touch-action: none;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
  }
  button {
    font-size: 1.2em;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    background: #444;
    color: white;
  }
  #popup {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 30px;
    background: rgba(200,0,0,0.9);
    color: white;
    font-size: 2em;
    font-weight: bold;
    border-radius: 8px;
    display: none;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="controls">
  <button id="nextPint">Next Pint</button>
  <button id="pauseBtn">Pause</button>
</div>
<div id="popup">YOU SUCK</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let phase = 'ready';
let tilt = 45;
let fill = 0;
let score = 0;
let totalScore = 0;
let paused = false;
let pouring = false;
let settleTimer = 0;
let targetSettle = 2000;
let lastTime = 0;
let bubbleOffset = 0;
let confetti = [];
let confettiTimer = 0;
let popupTimer = 0;
const popupDiv = document.getElementById('popup');

// Touch controls
let lastY = null;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (phase === 'ready') phase = 'pour1';
  if (phase === 'pour1' || phase === 'pour2') pouring = true;
  lastY = e.touches[0].clientY;
}, {passive: false});

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  pouring = false;
  if (phase === 'pour1') { phase = 'settle'; settleTimer = 0; }
  else if (phase === 'pour2') { phase = 'done'; checkScore(); }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const y = e.touches[0].clientY;
  if (lastY != null) {
    tilt += (lastY - y) * 0.2;
    if (tilt < 0) tilt = 0;
    if (tilt > 90) tilt = 90;
  }
  lastY = y;
}, {passive: false});

document.getElementById('nextPint').addEventListener('click', () => {
  phase = 'pour1';
  fill = 0;
  tilt = 45;
  score = 0;
});

document.getElementById('pauseBtn').addEventListener('click', () => {
  paused = !paused;
});

function checkScore() {
  if (fill >= 0.98 && fill <= 1.0) score = 100;
  else if (fill >= 0.95) score = 75;
  else if (fill >= 0.90) score = 50;
  else score = 25;

  totalScore += score;

  if (score >= 75) {
    startConfetti();
  } else if (score < 50) {
    showPopup();
  }
}

function showPopup() {
  popupDiv.style.display = 'block';
  popupTimer = 3000; // ms
}

function startConfetti() {
  confetti = [];
  for (let i=0; i<150; i++) {
    confetti.push({
      x: Math.random()*canvas.width,
      y: Math.random()*-canvas.height,
      r: Math.random()*6+4,
      dx: Math.random()*2-1,
      dy: Math.random()*3+2,
      color: `hsl(${Math.random()*360}, 100%, 50%)`
    });
  }
  confettiTimer = 3000; // ms
}

function updateConfetti(dt) {
  if (confettiTimer > 0) {
    confettiTimer -= dt;
    confetti.forEach(c => {
      c.x += c.dx;
      c.y += c.dy;
      if (c.y > canvas.height) c.y = -10;
    });
  }
}

function drawConfetti() {
  if (confettiTimer > 0) {
    confetti.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.fillStyle = c.color;
      ctx.fill();
    });
  }
}

function update(dt) {
  if (paused) return;
  if ((phase === 'pour1' || phase === 'pour2') && pouring) {
    let speed = (1 - tilt/90) * dt * 0.0003;
    fill += speed;
    if (phase === 'pour1' && fill > 0.75) fill = 0.75;
    if (phase === 'pour2' && fill > 1.05) fill = 1.05;
  }
  if (phase === 'settle') {
    settleTimer += dt;
    bubbleOffset += dt * 0.05;
    if (settleTimer >= targetSettle) phase = 'pour2';
  }
  if (popupTimer > 0) {
    popupTimer -= dt;
    if (popupTimer <= 0) popupDiv.style.display = 'none';
  }
  updateConfetti(dt);
}

function drawGlassShape() {
  ctx.beginPath();
  ctx.moveTo(-50, -200);
  ctx.quadraticCurveTo(-40, 0, -20, 200);
  ctx.lineTo(20, 200);
  ctx.quadraticCurveTo(40, 0, 50, -200);
  ctx.closePath();
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.stroke();
}

function drawBeer() {
  const beerColor = '#2d1b10';
  ctx.fillStyle = beerColor;
  const beerHeight = 400 * fill;
  const foamHeight = 15;
  let slosh = Math.sin(Date.now()/200) * 5 * (tilt/90);

  ctx.beginPath();
  ctx.moveTo(-48, 200);
  ctx.lineTo(-40, 200 - beerHeight);
  ctx.lineTo(40, 200 - beerHeight + slosh);
  ctx.lineTo(48, 200);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#f5f0e1';
  ctx.beginPath();
  ctx.moveTo(-40, 200 - beerHeight);
  ctx.quadraticCurveTo(0, 200 - beerHeight - foamHeight, 40, 200 - beerHeight + slosh);
  ctx.fill();

  if (phase === 'settle') {
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    for (let i=0; i<20; i++) {
      let bx = (Math.random()*60)-30;
      let by = 200 - (Math.random()*beerHeight) + ((bubbleOffset + i*10) % beerHeight);
      ctx.beginPath();
      ctx.arc(bx, by, 2, 0, Math.PI*2);
      ctx.fill();
    }
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate((tilt - 45) * Math.PI / 180 * 0.5);

  drawGlassShape();
  drawBeer();

  ctx.restore();

  ctx.fillStyle = 'white';
  ctx.font = '20px sans-serif';
  ctx.fillText(`Tilt: ${tilt.toFixed(0)}Â°`, 10, 30);
  ctx.fillText(`Fill: ${(fill*100).toFixed(0)}%`, 10, 60);
  ctx.fillText(`This Pint: ${score}`, 10, 90);
  ctx.fillText(`Total Score: ${totalScore}`, 10, 120);
  ctx.fillText(`Phase: ${phase}`, 10, 150);

  drawConfetti();
}

function loop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = timestamp - lastTime;
  lastTime = timestamp;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>

</body>
</html>
